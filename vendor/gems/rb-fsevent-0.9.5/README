<p><a href="https://codeclimate.com/github/thibaudgg/rb-fsevent"><img src="https://codeclimate.com/badge.png" alt="Code Climate"></a>
<a href="https://coderwall.com/ttilley"><img src="https://api.coderwall.com/ttilley/endorsecount.png" alt="endorse"></a></p>

<h1>rb-fsevent</h1>

<p>Very simple &amp; usable Mac OSX FSEvents API</p>

<ul>
<li>RubyCocoa not required!</li>
<li>Signals are working (really)</li>
<li>Tested on MRI 2.1, RBX 2.5, JRuby</li>
<li>Tested on 10.10</li>
</ul>

<h2>HFS+ filename corruption bug</h2>

<p>There is a <em>very</em> long-standing (since 2011) OSX bug where sometimes the filename metadata for HFS+ filesystems will get corrupted, resulting in some APIs returning one case for a file, and other APIs returning another. This corruption is not currently fixed by their tools, though Apple has been made aware of the issue and are working on it (as of may 2015). The result is that sometimes, <em>for no visible reason to the user</em>, fsevents would simply not work. As of rb-fsevent 0.9.5 this issue is properly detected and an insanely hacky (but effective) workaround is used that replaces the system <code>realpath()</code> with a custom implementation that should always return the same value as the kernel reporting (thus fixing fsevents).</p>

<p>Please note that this doesn&#39;t repair the underlying issue on disk. Other apps and libraries using fsevents will continue to break with no warning. There may be other issues unrelated to fsevents.</p>

<h2>Install</h2>

<pre><code>gem install rb-fsevent
</code></pre>

<h3>re-compilation</h3>

<p>rb-fsevent comes with a pre-compiled fsevent_watch binary supporting x86_64 on 10.9 and above. The binary is codesigned with my (Travis Tilley) Developer ID as an extra precaution when distributing pre-compiled code and contains an embedded plist describing its build environment. This should be sufficient for most users, but if you need to use rb-fsevent on 10.8 or lower then recompilation is necessary. This can be done by entering the installed gem&#39;s ext directory and running:</p>

<pre><code>MACOSX_DEPLOYMENT_TARGET=&quot;10.7&quot; rake replace_exe
</code></pre>

<p>The following ENV vars are recognized:</p>

<ul>
<li>CC</li>
<li>CFLAGS</li>
<li>ARCHFLAGS</li>
<li>MACOSX_DEPLOYMENT_TARGET</li>
<li>FWDEBUG (enables debug mode, printing an obscene number of informational
messages to STDERR)</li>
</ul>

<h3>embedded plist</h3>

<p>You can retrieve the values in the embedded plist via the CLI:</p>

<pre><code>fsevent_watch --show-plist
</code></pre>

<p>The output is essentially formatted as <code>&quot;#{key}:\n  #{value}\n&quot;</code> to make it easier to read than plist style xml. The result looks like this:</p>

<pre><code>DTSDKName:
  macosx10.5
FSEWBuildTriple:
  i386-apple-darwin10.8.0
FSEWCC:
  /usr/bin/gcc-4.2
DTSDKPath:
  /Developer/SDKs/MacOSX10.5.sdk
FSEWCCVersion:
  i686-apple-darwin10-gcc-4.2.1 (GCC) 4.2.1 (Apple Inc. build 5666) (dot 3)
FSEWCFLAGS:
  -fconstant-cfstrings -fno-strict-aliasing -Wall -mmacosx-version-min=10.5 -O3
</code></pre>

<p>If, for some perverse reason, you prefer to look at the xml... it can be retrieved via:</p>

<pre><code>otool -s __TEXT __info_plist ./bin/fsevent_watch | grep ^0 | xxd -r -
</code></pre>

<h3>codesign</h3>

<p>You can verify code signing information for a specific fsevent_watch via:</p>

<pre><code>codesign -d -vvv ./bin/fsevent_watch
</code></pre>

<p>If you&#39;re using the pre-compiled binary, then the output should contain something to the effect of:</p>

<pre><code>Authority=Developer ID Application: Travis Tilley
Authority=Developer ID Certification Authority
Authority=Apple Root CA
Timestamp=Dec 31, 2012 12:49:13 PM
</code></pre>

<h2>Usage</h2>

<h3>Singular path</h3>

<p>```ruby
require &#39;rb-fsevent&#39;</p>

<p>fsevent = FSEvent.new
fsevent.watch Dir.pwd do |directories|
  puts &quot;Detected change inside: #{directories.inspect}&quot;
end
fsevent.run
```</p>

<h3>Multiple paths</h3>

<p>```ruby
require &#39;rb-fsevent&#39;</p>

<p>paths = [&#39;/tmp/path/one&#39;, &#39;/tmp/path/two&#39;, Dir.pwd]</p>

<p>fsevent = FSEvent.new
fsevent.watch paths do |directories|
  puts &quot;Detected change inside: #{directories.inspect}&quot;
end
fsevent.run
```</p>

<h3>Multiple paths and additional options as a Hash</h3>

<p>```ruby
require &#39;rb-fsevent&#39;</p>

<p>paths = [&#39;/tmp/path/one&#39;, &#39;/tmp/path/two&#39;, Dir.pwd]
options = {:latency =&gt; 1.5, :no_defer =&gt; true }</p>

<p>fsevent = FSEvent.new
fsevent.watch paths, options do |directories|
  puts &quot;Detected change inside: #{directories.inspect}&quot;
end
fsevent.run
```</p>

<h3>Multiple paths and additional options as an Array</h3>

<p>```ruby
require &#39;rb-fsevent&#39;</p>

<p>paths = [&#39;/tmp/path/one&#39;, &#39;/tmp/path/two&#39;, Dir.pwd]
options = [&#39;--latency&#39;, 1.5, &#39;--no-defer&#39;]</p>

<p>fsevent = FSEvent.new
fsevent.watch paths, options do |directories|
  puts &quot;Detected change inside: #{directories.inspect}&quot;
end
fsevent.run
```</p>

<h2>Options</h2>

<p>When defining options using a hash or hash-like object, it gets checked for validity and converted to the appropriate fsevent_watch commandline arguments array when the FSEvent class is instantiated. This is obviously the safest and preferred method of passing in options.</p>

<p>You may, however, choose to pass in an array of commandline arguments as your options value and it will be passed on, unmodified, to the fsevent_watch binary when called.</p>

<p>So far, the following options are supported:</p>

<ul>
<li>:latency =&gt; 0.5 # in seconds</li>
<li>:no_defer =&gt; true</li>
<li>:watch_root =&gt; true</li>
<li>:since_when =&gt; 18446744073709551615 # an FSEventStreamEventId</li>
<li>:file_events =&gt; true</li>
</ul>

<h3>Latency</h3>

<p>The :latency parameter determines how long the service should wait after the first event before passing that information along to the client. If your latency is set to 4 seconds, and 300 changes occur in the first three, then the callback will be fired only once. If latency is set to 0.1 in the exact same scenario, you will see that callback fire somewhere closer to between 25 and 30 times.</p>

<p>Setting a higher latency value allows for more effective temporal coalescing, resulting in fewer callbacks and greater overall efficiency... at the cost of apparent responsiveness. Setting this to a reasonably high value (and NOT setting :no_defer) is particularly well suited for background, daemon, or batch processing applications.</p>

<p>Implementation note: It appears that FSEvents will only coalesce events from a maximum of 32 distinct subpaths, making the above completely accurate only when events are to fewer than 32 subpaths. Creating 300 files in one directory, for example, or 30 files in 10 subdirectories, but not 300 files within 300 subdirectories. In the latter case, you may receive 31 callbacks in one go after the latency period. As this appears to be an implementation detail, the number could potentially differ across OS revisions. It is entirely possible that this number is somehow configurable, but I have not yet discovered an accepted method of doing so.</p>

<h3>NoDefer</h3>

<p>The :no_defer option changes the behavior of the latency parameter completely. Rather than waiting for $latency period of time before sending along events in an attempt to coalesce a potential deluge ahead of time, that first event is sent along to the client immediately and is followed by a $latency period of silence before sending along any additional events that occurred within that period.</p>

<p>This behavior is particularly useful for interactive applications where that feeling of apparent responsiveness is most important, but you still don&#39;t want to get overwhelmed by a series of events that occur in rapid succession.</p>

<h3>WatchRoot</h3>

<p>The :watch_root option allows for catching the scenario where you start watching &quot;~/src/demo_project&quot; and either it is later renamed to &quot;~/src/awesome_sauce_3000&quot; or the path changes in such a manner that the original directory is now at &quot;~/clients/foo/iteration4/demo_project&quot;.</p>

<p>Unfortunately, while this behavior is somewhat supported in the fsevent_watch binary built as part of this project, support for passing across detailed metadata is not (yet). As a result, you would not receive the appropriate RootChanged event and be able to react appropriately. Also, since the C code doesn&#39;t open watched directories and retain that file descriptor as part of path-specific callback metadata, we are unable to issue an F_GETPATH fcntl() to determine the directory&#39;s new path.</p>

<p>Please do not use this option until proper support is added (or, even better, add it and submit a pull request).</p>

<h3>SinceWhen</h3>

<p>The FSEventStreamEventId passed in to :since_when is used as a base for reacting to historic events. Unfortunately, not only is the metadata for transitioning from historic to live events not currently passed along, but it is incorrectly passed as a change event on the root path, and only per-host event streams are currently supported. When using per-host event streams, the event IDs are not guaranteed to be unique or contiguous when shared volumes (firewire/USB/net/etc) are used on multiple macs.</p>

<p>Please do not use this option until proper support is added, unless it&#39;s acceptable for you to receive that one fake event that&#39;s handled incorrectly when events transition from historical to live. Even in that scenario, there&#39;s no metadata available for determining the FSEventStreamEventId of the last received event.</p>

<p>WARNING: passing in 0 as the parameter to :since_when will return events for every directory modified since &quot;the beginning of time&quot;.</p>

<h3>FileEvents</h3>

<p>Prepare yourself for an obscene number of callbacks. Realistically, an &quot;Atomic Save&quot; could easily fire maybe 6 events for the combination of creating the new file, changing metadata/permissions, writing content, swapping out the old file for the new may itself result in multiple events being fired, and so forth. By the time you get the event for the temporary file being created as part of the atomic save, it will already be gone and swapped with the original file. This and issues of a similar nature have prevented me from adding the option to the ruby code despite the fsevent_watch binary supporting file level events for quite some time now. Mountain Lion seems to be better at coalescing needless events, but that might just be my imagination.</p>

<h2>Debugging output</h2>

<p>If the gem is re-compiled with the environment variable FWDEBUG set, then fsevent_watch will be built with its various DEBUG sections defined, and the output to STDERR is truly verbose (and hopefully helpful in debugging your application and not just fsevent_watch itself). If enough people find this to be directly useful when developing code that makes use of rb-fsevent, then it wouldn&#39;t be hard to clean this up and make it a feature enabled by a commandline argument instead. Until somebody files an issue, however, I will assume otherwise.</p>

<pre><code>append_path called for: /tmp/moo/cow/
  resolved path to: /private/tmp/moo/cow

config.sinceWhen    18446744073709551615
config.latency      0.300000
config.flags        00000000
config.paths
  /private/tmp/moo/cow

FSEventStreamRef @ 0x100108540:
   allocator = 0x7fff705a4ee0
   callback = 0x10000151e
   context = {0, 0x0, 0x0, 0x0, 0x0}
   numPathsToWatch = 1
   pathsToWatch = 0x7fff705a4ee0
        pathsToWatch[0] = &#39;/private/tmp/moo/cow&#39;
   latestEventId = -1
   latency = 300000 (microseconds)
   flags = 0x00000000
   runLoop = 0x0
   runLoopMode = 0x0

FSEventStreamCallback fired!
  numEvents: 32
  event path: /private/tmp/moo/cow/1/a/
  event flags: 00000000
  event ID: 1023767
  event path: /private/tmp/moo/cow/1/b/
  event flags: 00000000
  event ID: 1023782
  event path: /private/tmp/moo/cow/1/c/
  event flags: 00000000
  event ID: 1023797
  event path: /private/tmp/moo/cow/1/d/
  event flags: 00000000
  event ID: 1023812
  [etc]
</code></pre>

<h2>Development</h2>

<ul>
<li>Source hosted at <a href="http://github.com/thibaudgg/rb-fsevent">GitHub</a></li>
<li>Report issues/Questions/Feature requests on <a href="http://github.com/thibaudgg/rb-fsevent/issues">GitHub Issues</a></li>
</ul>

<p>Pull requests are quite welcome! Please ensure that your commits are in a topic branch for each individual changeset that can be reasonably isolated. It is also important to ensure that your changes are well tested... whether that means new tests, modified tests, or fixing a scenario where the existing tests currently fail. If you have rbenv and ruby-build, we have a helper task for running the testsuite in all of them:</p>

<pre><code>rake spec:portability
</code></pre>

<p>The list of tested targets is currently:</p>

<pre><code>%w[2.2.2 2.3.0-dev rbx-2.5.5 jruby-1.7.9]
</code></pre>

<h2>Authors</h2>

<ul>
<li><a href="http://github.com/ttilley">Travis Tilley</a></li>
<li><a href="http://github.com/thibaudgg">Thibaud Guillaume-Gentil</a></li>
<li><a href="https://github.com/andreyvit">Andrey Tarantsov</a></li>
</ul>
